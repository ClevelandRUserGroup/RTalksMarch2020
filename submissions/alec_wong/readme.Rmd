---
output: github_document
author: Alec Wong
title: Housing data mini-analysis
---

```{r setup, warning=FALSE, message=FALSE}
library(dplyr)
library(data.table)
library(readr)
library(purrr)
library(mapsapi)
library(xml2)
library(sf)
library(ggrepel)
library(xgboost)
library(ggmap)
library(memoise)

source("R/load_all_data.R")
source("R/modeling_functions.R")

data = load_data()

# The test dataset has no SalePrice to work with; omit these
data = data %>% filter(train_test == 1)

knitr::opts_chunk$set(comment = NA, 
                      fig.path = 'output/figures/', 
                      fig.width = 10, 
                      fig.height = 5, 
                      dpi = 300, 
                      dev.args = list(type = "cairo"))
```

# Housing data

The data are sourced from the Kaggle competition found here: https://www.kaggle.com/c/house-prices-advanced-regression-techniques

I used the Kaggle API to download the data:

```
kaggle competitions download -c house-prices-advanced-regression-techniques
```

The `data_description.txt` file contains all the relevant metadata on the
dataset.

Among the many variables included in the dataset here, the `Neighborhoods`
variable caught my eye. It was clear from the `data_description.txt` file that
the neighborhoods were located in Ames, Iowa. The objective of this short
exploration became:

* Geocode the neighborhoods.
* See if including the neighborhood spatial information improves prediction.

## Neighborhood values

The neighborhood values take on the following, as described in the
`data_description.txt` file. It was tab-delimited already within the text file,
so I extracted it into its own `.tsv` file.

```{r}
neighborhoods = readr::read_delim(file = 'data/neighborhoods_match.tsv', 
                                  delim = '\t', 
                                  col_names = c("abbreviation", "neighborhood"),
                                  col_types = cols(col_character(), col_character())
)

neighborhoods %>% print(n = 100)
```

There are 25 neighborhoods, and after entering some of these by hand, most of
these have some definition using the
[Google Maps Geocoding API](https://developers.google.com/maps/documentation/geocoding/intro).

The neighborhoods have some moderate correlation with housing cost, and
intuitively one would assume that neighborhoods closer together might covary
more than neighborhoods farther apart.

```{r}
data %>% 
  ggplot() + 
  geom_boxplot(aes(x = Neighborhood, y = SalePrice)) + 
  theme_bw() + 
  scale_x_discrete(guide = guide_axis(n.dodge = 3)) + 
  scale_y_continuous(labels = scales::dollar, breaks = seq(0, 1e6, by = 1e5))
```

While I noticed this later on, one of the neighborhood values actually doesn't
align with the description data *exactly*; the casing is different:

```{r}
setdiff(data$Neighborhood, neighborhoods$abbreviation)
setdiff(neighborhoods$abbreviation, data$Neighborhood)
```

Of course the name is artificial anyway, but for matching purposes later on, I
just `tolower` all the neighborhood references.

```{r}
neighborhoods$abbreviation = tolower(neighborhoods$abbreviation)
data$Neighborhood = tolower(data$Neighborhood)
```

Additionally, two of the neighborhood locations don't have any suitable geocoded
location from Google Maps, which puts them in Seattle; these are the `swisu`, or
`South & West of Iowa State University`, and `npkvill`, or `Northpark Villa`
locations. The first, `swisu`, I impute instead simply Iowa State University as
a stop-gap, since "south and west" of it isn't much more informative. The
`Northpark Villa` is more of an anomaly, as searching "Northpark" in Google Maps
doesn't turn anything up in the relatively small town of Ames. I end up omitting
these records for this exercise.

## Testing out the Geocoding API

I make use of Google's Geocode API and the corresponding package `mapsapi` to
interface with it through R.

```{r api-key}
api_key = Sys.getenv("gmaps_api_key")
```

I can obtain a bounding box for Ames, Iowa, and with `ggmap`, plot it. Before I
do, I want to memoise the `mp_geocode` function, which stores the results in
cache in memory and accesses those saved values for any function calls with
duplicate arguments. This will avoid unnecessary calls to the API as I develop.

```{r memoize-geocode}
mm_mp_geocode = memoise::memoise(f = function(address, key){mp_geocode(address, key = api_key)})
```

What returns is essentially an XML response with some metadata and location
information, as well as return status.

```{r geocode-ames, cache = TRUE}
ames_bb = mm_mp_geocode("ames, iowa", key = api_key)
ames_bb
```

`mapsapi` interacts with this XML response directly, and we can get points, polygons, and boundaries from the response.

```{r plot-ames-map, cache = TRUE}
ames_poly = mp_get_bounds(ames_bb)
ames_pt   = mp_get_points(ames_bb)
ggmap::register_google(key = api_key)
ames_ia_map = suppressMessages(ggmap::get_map(location = sf::st_coordinates(ames_pt), zoom = 12, source = 'google', messaging = FALSE)) 

ggmap(ggmap = ames_ia_map) + 
  geom_polygon(data = ames_poly %>% st_coordinates() %>% as.data.frame, aes(x = X, y = Y),
               fill = NA, color = 'red4')
```

Great.

## Geocoding the neighborhoods

To input the neighborhoods into the Geocoding API, I can't just give it the
names; I will need to give "Ames, Iowa" as context so that it doesn't get data
from just any location. I make a new column in the `neighborhoods` data to
search with, by appending "Ames, Iowa" to the neighborhood name. Also, as
mentioned before, `swisu` and `npkvill` don't really have good matches, so I
modify those appropriately.

```{r format-neigh-search}
# the search column will be use for the 'address' argument in mp_geocode
neighborhoods$search = stringr::str_c(neighborhoods$neighborhood, ", Ames Iowa")

# `South and West of Iowa State University` is no good, so I impute just the university name
neighborhoods = neighborhoods %>%
  mutate(search = case_when(
    abbreviation == 'swisu' ~ "Iowa State University",
    TRUE ~ search
  )) %>% 
  filter(abbreviation != "npkvill")

neighborhoods$search

```

I'm ready to plug each of these addresses into the `mp_geocode` function, or
rather our memoised version of it.

```{r geocode-neighbors, cache = TRUE}
neigh_geocode = mm_mp_geocode(address = neighborhoods$search, key = api_key)
```


---

```{r}
sessionInfo()
```
